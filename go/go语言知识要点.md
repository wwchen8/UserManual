# 目录

* [包](#包)
  * [main包](#main包)
  * [包的导入](#包的导入)
  * [函数init](#函数init)
* [数组、切片和映射](#数组、切片和映射)
  * [数组](#数组)
* [源码安装Geth](#源码安装Geth)




---
# 包

所有 Go 语言的程序都会组织成若干组文件，每组文件被称为一个包。 Go 语言的每个代码文件都属于一个包。

一个包定义一组编译过的代码，包的名字类似命名空间，可以用来间接访问包内声明的标识符。
所有的.go 文件，除了空行和注释，都应该在第一行声明自己所属的包。每个包都在一个单
独的目录里。给包命名的惯例是使用包所在目录的名字。

## main包
``` go
package main
```
在Go 语言里，命名为main 的包具有特殊的含义。Go 语言的编译程序会试图把这种名字的包编译为二进制可执行文件。所有用Go 语言编译的可执行程序都必须有一个名叫main 的包。
当编译器发现某个包的名字为main 时，它一定也会发现名为main()的函数，否则不会创建可执行文件。

在Go 语言里，标识符要么从包里公开，要么不从包里公开。**包里以大写字母开头的标识符是公开的。以小写字母开头的标识符是不公开的，不能被其他包中的代码直接访问。**

## 包的导入
``` go
import "fmt"
import (
    "strings"
    _ "mypackage"
)

```
关键字import 就是导入一段代码，让用户可以访问其中的标识符，如类型、函数、常量和接口。编译器会使用Go 环境变量设置的路径，通过引入的相对路径来查找磁盘上的包。

**Go 编译器不允许声明导入某个包却不使用。** 下划线 _ 让编译器接受这类导入，并且调用对应包内的所有代码文件里定义的init 函数。

- 远程导入:

``` go
import "github.com/spf13/viper"
```

- 重命名导入:

``` go
import (
    myfmt "/utils/fmt"
)
```

## 函数init
每个包可以包含任意多个init 函数，这些函数都会在程序执行开始的时候被调用。所有被编译器发现的init 函数都会安排在main 函数之前执行。init 函数用在设置包、初始化变量或者其他要在程序运行前优先完成的引导工作。



---
# 数组、切片和映射



## 数组

在Go 语言里，数组是一个长度固定的数据类型，用于存储一段具有相同的类型的元素的连续块。数组存储的类型可以是内置类型，如整型或者字符串，也可以是某种结构类型。

1. 声明和初始化

```go
代码清单 声明一个数组，并设置为零值

// 声明一个包含5 个元素的整型数组
var array [5]int

// 声明一个包含5 个元素的整型数组, 用具体值初始化每个元素
array := [5]int{10, 20, 30, 40, 50}

// 声明一个有5 个元素的数组，用具体值初始化索引为1 和2 的元素，其余元素保持零值
array := [5]int{1: 10, 2: 20}

// 容量由初始化值的数量决定
array := [...]int{10, 20, 30, 40, 50}
```

**<u>一旦声明，数组里存储的数据类型和数组长度就都不能改变了。</u>**

2. 使用数组

```go
代码清单 访问数组元素
// 声明一个包含5 个元素的整型数组,用具体值初始为每个元素
array := [5]int{10, 20, 30, 40, 50}

// 修改索引为2 的元素的值
array[2] = 35
```

```go
代码清单 把同样类型的一个数组赋值给另外一个数组
// 声明第一个包含5 个元素的字符串数组
var array1 [5]string
// 声明第二个包含5 个元素的字符串数组, 用颜色初始化数组
array2 := [5]string{"Red", "Blue", "Green", "Yellow", "Pink"}
// 把array2 的值复制到array1
array1 = array2
```

数组变量的类型包括数组长度和每个元素的类型。**只有这两部分都相同的数组，才是类型相同的数组，才能互相赋值**。

3. 多维数组

```go
代码清单  声明二维数组
// 声明一个二维整型数组，两个维度分别存储4 个元素和2 个元素
var array [4][2]int

// 使用数组字面量来声明并初始化一个二维整型数组
array := [4][2]int{{10, 11}, {20, 21}, {30, 31}, {40, 41}}

// 声明并初始化外层数组中索引为1 个和3 的元素
array := [4][2]int{1: {20, 21}, 3: {40, 41}}

// 声明并初始化外层数组和内层数组的单个元素
array := [4][2]int{1: {0: 20}, 3: {1: 41}}

// 使用索引为多维数组赋值
// 将 array1 的索引为1 的维度复制到一个同类型的新数组里
var array1 [2][2]int
var array3 [2]int = array1[1]

// 将外层数组的索引为1、内层数组的索引为0 的整型值复制到新的整型变量里
var value int = array1[1][0]
```

4. 在函数间传递数组

**在函数之间传递变量时，总是以值的方式传递的。**如果这个变量是一个数组，意味着整个数组，不管有多长，都会完整复制，并传递给函数。

将数组的地址传入函数，只需要在栈上分配8 字节的内存给指针就可以。这个操作会更有效地利用内存，性能也更好。不过要意识到，**因为现在传递的是指针，所以如果改变指针指向的值，会改变共享的内存**。



## 切片

切片是一种数据结构，这种数据结构便于使用和管理数据集合。切片是围绕动态数组的概念构建的，可以按需自动增长和缩小。切片的动态增长是通过内置函数append 来实现的。

1. 内部实现

切片是一个很小的对象，对底层数组进行了抽象，并提供相关的操作方法。切片有3 个字段的数据结构，这些数据结构包含Go 语言需要操作底层数组的元数据。

![image-20210913174049660](C:\Users\wwchen\AppData\Roaming\Typora\typora-user-images\image-20210913174049660.png)

2. 创建和初始化

```go
代码清单  使用长度声明一个字符串切片
// 创建一个字符串切片, 其长度和容量都是5 个元素
slice := make([]string, 5)

// 使用长度和容量声明整型切片
// 创建一个整型切片. 其长度为3 个元素，容量为5 个元素
slice := make([]int, 3, 5)
```

```go
代码清单  通过切片字面量来声明切片
// 创建字符串切片. 其长度和容量都是5 个元素
slice := []string{"Red", "Blue", "Green", "Yellow", "Pink"}

// 创建一个整型切片. 其长度和容量都是3 个元素
slice := []int{10, 20, 30}
```

当使用切片字面量时，可以设置初始长度和容量。要做的就是在初始化时给出所需的长度和容量作为索引。

```go
// 创建字符串切片. 使用空字符串初始化第100 个元素
slice := []string{99: ""}
```

**声明数组和声明切片的不同:**

```go
// 创建有3 个元素的整型数组
array := [3]int{10, 20, 30}

// 创建长度和容量都是3 的整型切片
slice := []int{10, 20, 30}
```

**nil 和空切片:**

在声明时不做任何初始化，就会创建一个nil 切片。

利用初始化，通过声明一个切片可以创建一个空切片。

```go
// 创建nil 整型切片
var slice []int

// 使用make 创建空的整型切片
slice := make([]int, 0)

// 使用切片字面量创建空的整型切片
slice := []int{}
```

![image-20210913175524760](C:\Users\wwchen\AppData\Roaming\Typora\typora-user-images\image-20210913175524760.png)

- **nil切片和空切片指向的地址不一样。nil空切片引用数组指针地址为0（无指向任何实际地址）**
- **空切片的引用数组指针地址是有的，且所有的空切片引用的为固定的同一个值**



3. 使用切片

   - 赋值和切片

     ```go
     代码清单  使用切片字面量来声明切片
     // 创建一个整型切片.其容量和长度都是5 个元素
     slice := []int{10, 20, 30, 40, 50}
     // 改变索引为1 的元素的值
     slice[1] = 25
     
     // 使用切片创建切片
     // 创建一个新切片. 其长度为2 个元素，容量为4 个元素
     newSlice := slice[1:3]
     ```

   ![image-20210913180134755](C:\Users\wwchen\AppData\Roaming\Typora\typora-user-images\image-20210913180134755.png)

   现在两个切片共享同一个底层数组。如果一个切片修改了该底层数组的共享部分，另一个切片也能感知到。

   

   - 切片增长

     ```go
     代码清单 使用append 向切片增加元素
      
     // 使用原有的容量来分配一个新元素。将新元素赋值为60
     newSlice = append(newSlice, 60)
     
     ```

   ![image-20210913180634247](C:\Users\wwchen\AppData\Roaming\Typora\typora-user-images\image-20210913180634247.png)

   

   **如果切片的底层数组没有足够的可用容量，append 函数会创建一个新的底层数组，将被引用的现有的值复制到新数组里，再追加新的值。**

   

   - 创建切片时的3 个索引

   在创建切片时，还可以使用之前我们没有提及的第三个索引选项。第三个索引可以用来控制新切片的容量。其目的并不是要增加容量，而是要**限制容量**。

   ```go
   代码清单  使用切片字面量声明一个字符串切片
   // 创建字符串切片。其长度和容量都是5 个元素
   source := []string{"Apple", "Orange", "Plum", "Banana", "Grape"}
   
   // 将第三个元素切片，并限制容量. 其长度为1 个元素，容量为2 个元素
   slice := source[2:3:4]
   ```

   ![image-20210913181613996](C:\Users\wwchen\AppData\Roaming\Typora\typora-user-images\image-20210913181613996.png)

   **如果试图设置的容量比可用的容量还大，就会得到一个语言运行时错误。**

   在创建切片时设置切片的容量和长度一样，就可以强制让新切片的第一个append 操作创建新的底层数组，与原有的底层数组分离。新切片与原有的底层数组分离后，可以安全地进行后续修改，而不用担心会不小心修改了其他切片里的数据。

   **内置函数append** 也是一个**可变参数的函数**。这意味着可以在一次调用传递多个追加的值。如果使用**...运算符**，可以将一个切片的所有元素追加到另一个切片里。

   ```go
   // 创建两个切片，并分别用两个整数进行初始化
   s1 := []int{1, 2}
   s2 := []int{3, 4}
   
   // 将两个切片追加在一起，并显示结果
   fmt.Printf("%v\n", append(s1, s2...))
   Output:
   [1 2 3 4]
   ```

   

   - 迭代切片

     Go 语言有个特殊的关键字range，它可以配合关键字for 来迭代切片里的元素.

   ```go
     代码清单  使用for range 迭代切片
     // 创建一个整型切片.其长度和容量都是4 个元素
     slice := []int{10, 20, 30, 40}
     
     // 迭代每一个元素，并显示其值
     for index, value := range slice {
     	fmt.Printf("Index: %d Value: %d\n", index, value)
     }
     Output:
     Index: 0 Value: 10
     Index: 1 Value: 20
     Index: 2 Value: 30
     Index: 3 Value: 40
   ```

   **需要强调的是，range 创建了每个元素的副本，而不是直接返回对该元素的引用。如果使用该值变量的地址作为指向每个元素的指针，就会造成错误。**因为迭代返回的变量是一个迭代过程中根据切片依次赋值的新变量，所以value 的地址总是相同的。要想获取每个元素的地址，可以使用切片变量和索引值。
   
   ```go
   代码清单 使用传统的for 循环对切片进行迭代
   // 创建一个整型切片. 其长度和容量都是4 个元素
   slice := []int{10, 20, 30, 40}
   
   // 从第三个元素开始迭代每个元素
   for index := 2; index < len(slice); index++ {
   	fmt.Printf("Index: %d Value: %d\n", index, slice[index])
   }
   Output:
   Index: 2 Value: 30
   Index: 3 Value: 40
   ```
   
   有两个特殊的**内置函数len 和cap**，可以用于处理数组、切片和通道。对于切片，函数len返回切片的长度，函数cap 返回切片的容量。



4. 多维切片



如果要调用的函数返回多个值，而又不需要其中的某个值，就可以使用下划线标识符将其忽略。

在Go 语言中，所有变量都被初始化为其零值。对于数值类型，零值是0；对于字符串类型，
零值是空字符串；对于布尔类型，零值是false；对于指针，零值是nil。对于引用类型来说，
所引用的底层数据结构会被初始化为对应的零值。


关键字func 声明函数，关键字后面紧跟着函数名、参数以及返回值。
如果声明函数的时候带有接收者，则意味着声明了一个方法。这个方法会和指定的接收者的
类型绑在一起。

如果需要声明初始值为零值
的变量，应该使用var 关键字声明变量；如果提供确切的非零值初始化变量或者使用函数返回
值创建变量，应该使用简化变量声明运算符。


关键字 defer 会安排随后的函数调用在函数返回时才执行。

interface 关键字声明了一个接口，这个接口声明了结构
类型或者具名类型需要实现的行为。一个接口的行为最终由在这个接口类型中声明的方法决定。
